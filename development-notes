1. 路由
2. 响应式设计 {
    媒体查询：<600(手机), 600-900(平板), 大于901(桌面)
    react-bootstrap 
}
3. 用户界面用户体验 material-ui（不使用css文件）：
4. 可访问性  Axe/WAVE
5. 代码esLint
hint:
1.字体："Heiti TC"
2.颜色：人体三感知器官，对应蓝绿红，蓝色是最安全的颜色，绿色是最舒适的颜色，红色是最激烈的颜色，构成RGB三原色，对应xyz三个值
HSL：色相、饱和度、亮度中相同色相的颜色更和谐，可以用公示将其转化为RGB值,经典HSL值为199,86,90/199,86,51/199,100,35。可以用Paletton网站来选择颜色
function turnHSLToRGB(h, s, l) {
  // h, s, l are in [0, 1]
  let c = (1 - Math.abs(2 * l - 1)) * s;
  let x = c * (1 - Math.abs((h / 60) % 2 - 1));
  let m = l - c / 2;
  let r, g, b;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
} 


4.路由：import React from 'react';
import { Link, useNavigate } from 'react-router-dom';

function LoginPage() {
  const navigate = useNavigate();

  const handleRegisterClick = () => {
    navigate('/register');
  };

  return (
    <div>
      <h1>Login Page</h1>
      <button onClick={handleRegisterClick}>Go to Register Page</button>
    </div>
  );
}

export default LoginPage;


5.presto中，为了使得右侧presentation缩略图展示栏，每行的grid子项数根据grid container的宽度变化而不是根据屏幕宽度，
使用useRef引用container元素，同时采用ResizeObserver监视useRef.current的变化，变化时触发回调函数handleResize，改变state量cols，进而控制子项。

6.使用js原生的触发器控制画布上元素的移动不太流畅，尝试使用react dnd, 部署代码=>useDrop左边第一个参数不能为空，不然会引起无限循环报错。
const delta = monitor.getDifferenceFromInitialOffset();返回的是px，必须与paper盒子的宽高处理得到百分比，要得到百分比需要引用paper结点
由于已经有个来自useDrop的ref，所以需要引入useCallback，将两个ref合并，传递给useDrop的ref，同时将其中一个ref传递给另一个ref，这样就可以在回调函数中使用paperRef.current
最后使用  const { width, height } = paperRef.current.getBoundingClientRect();
        delta.x = delta.x / width * 100;
        delta.y = delta.y / height * 100;

7.观察者
export class Game {
  knightPosition = [1, 7]
  observers = []
  observe(o) {
    this.observers.push(o)
    this.emitChange()
    return () => {
      this.observers = this.observers.filter((t) => t !== o)
    }
  }
  moveKnight(toX, toY) {
    this.knightPosition = [toX, toY]
    this.emitChange()
  }
  canMoveKnight(toX, toY) {
    const [x, y] = this.knightPosition
    const dx = toX - x
    const dy = toY - y
    return (
      (Math.abs(dx) === 2 && Math.abs(dy) === 1) ||
      (Math.abs(dx) === 1 && Math.abs(dy) === 2)
    )
  }
  emitChange() {
    const pos = this.knightPosition
    this.observers.forEach((o) => o && o(pos))
  }
}

然后在其他组件中使用观察者模式：
const [[knightX, knightY], setKnightPos] = useState(game.knightPosition)
useEffect(() => game.observe(setKnightPos))
这样当moveKnight被调用时，会触发emitChange，进而触发setKnightPos，更新knightX和knightY，从而更新组件。  

8 useCallback 合并ref
import { useCallback, useRef } from 'react';
 const paperRef = useRef(null);
  const combinedRef = useCallback(node => {
    drop(node); // 将节点传递给 useDrop 的 ref
    paperRef.current = node; // 将节点存储在 paperRef 中
  }, [drop]);
ref={combinedRef}
